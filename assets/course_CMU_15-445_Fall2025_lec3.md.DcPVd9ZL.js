import{_ as a,c as t,o as r,ae as l}from"./chunks/framework.BD_Yrv4e.js";const c=JSON.parse('{"title":"Files, Pages, Tuples","description":"","frontmatter":{},"headers":[],"relativePath":"course/CMU_15-445_Fall2025/lec3.md","filePath":"course/CMU_15-445_Fall2025/lec3.md"}'),o={name:"course/CMU_15-445_Fall2025/lec3.md"};function i(p,e,d,s,g,n){return r(),t("div",null,[...e[0]||(e[0]=[l('<h1 id="files-pages-tuples" tabindex="-1">Files, Pages, Tuples <a class="header-anchor" href="#files-pages-tuples" aria-label="Permalink to &quot;Files, Pages, Tuples&quot;">​</a></h1><p>这节课主要内容是 Background, File Storage, Page Layout, Tuple Layout</p><h2 id="disk-based-architecture" tabindex="-1">Disk-Based Architecture <a class="header-anchor" href="#disk-based-architecture" aria-label="Permalink to &quot;Disk-Based Architecture&quot;">​</a></h2><p>首先，数据库默认的主要存储位置位于持久化存储空间中，也就是硬盘，例如 SSD, HDD ，他们都是不能被直接操作的。如果要读取或者写入，需要先将数据加载到内存中，然后在内存中读取和写入。</p><h2 id="sequential-vs-random-access" tabindex="-1">Sequential VS Random Access <a class="header-anchor" href="#sequential-vs-random-access" aria-label="Permalink to &quot;Sequential VS Random Access&quot;">​</a></h2><p>随机读写取在硬盘中，几乎总是比顺序读写中慢，因此在磁盘的读取和写入中，经可能增加顺序读写，减少随机读写。</p><h2 id="disk-oriented-dbms" tabindex="-1">Disk-Oriented DBMS <a class="header-anchor" href="#disk-oriented-dbms" aria-label="Permalink to &quot;Disk-Oriented DBMS&quot;">​</a></h2><p>有的数据库文件存储为单个文件，例如 SQL-Lite ，但是大多数是多个文件，例如 MySQL ，但是不管怎么样，这些文件对于操作系统来说，都是一样的，本质都是使用 <code>fopen()</code>, <code>fread()</code>, <code>fwrite()</code> 操作他们。</p><p>这些文件中又进一步被分为许多长度固定的 Page ，通常在文件头会存储着 Page Directory 。</p><blockquote><p>当我要使用时，内存中通常会有一个 Buffer Pool ，还会有一个执行引擎。<br> 假设需要查询，执行引擎说：“我想要第二个 Page 的内容”，这时候就会将文件头中的 Page Directory 读进 Buffer Pool。<br> 然后从 Page Directory 中可以找到第二个 Page 的位置，加载进内存中。<br> 然后将指向该 Page 的指针交给执行引擎，执行引擎就可以使用第二个 Page 的数据了。<br> 执行引擎执行结束之前 Buffer Pool 会通过一种叫做 Page Pinning 的技术保证指针不会被替换或者与另一个页面交换，从而保证数据访问的绝对安全。<br> 当执行引擎运行结束后，会将数据更新到内存中的第二个 Page ，同时告诉 Buffer Pool ：“我完成了”。<br> 接着 Buffer Pool 就会将内存中的第二个 Page 写入硬盘的第二个 Page 中。</p></blockquote><h2 id="file-storage" tabindex="-1">File Storage <a class="header-anchor" href="#file-storage" aria-label="Permalink to &quot;File Storage&quot;">​</a></h2><p>现在的数据库文件格式，都是每个数据库独有的，不同的数据库文件在不同的数据库不通用。<br> 但是现在有了一种新的趋势，就是可移植的文件格式，例如： Parquet。</p><h2 id="storage-manager" tabindex="-1">Storage Manager <a class="header-anchor" href="#storage-manager" aria-label="Permalink to &quot;Storage Manager&quot;">​</a></h2><p>大多数数据库会有一个成为 Storage Manager 的东西，它是系统负责读取和写入磁盘数据的组件。通常是不希望让操作系统来调度和管理数据库文件，这会让数据库性能降低。</p><p>Storage Manager 会跟踪数据库文件中 Page 的读取和写入，并且它会跟踪可用空间。</p><h2 id="database-page" tabindex="-1">Database Page <a class="header-anchor" href="#database-page" aria-label="Permalink to &quot;Database Page&quot;">​</a></h2><p>Page 是一个固定大小的数据块，它基本包含数据库系统中的所有内容，例如： Tuple, Meta-Data, Indexs, Log Record 。</p><p>每个 Page 都有一个唯一的标识符(Page ID) ，Page ID 是数据库系统需要维护的唯一编号，用于跟踪 Page ，也有可能作为一个逻辑位置当作偏移量使用。</p><h3 id="page" tabindex="-1">Page <a class="header-anchor" href="#page" aria-label="Permalink to &quot;Page&quot;">​</a></h3><p>在系统中有三种 Page</p><blockquote><p>Hardware Page (通常 4KB)<br> OS Page (通常 4KB, x64 2MB/1GB)<br> Database Page (512B-32KB)</p></blockquote><p>Page 的大小没有好和坏的区分，只有合适与不合适的区别，通常来说，读密集型场景 Page 长度大比较好，写密集型场景 Page 长度小比较好。</p><h3 id="heap-file" tabindex="-1">Heap File <a class="header-anchor" href="#heap-file" aria-label="Permalink to &quot;Heap File&quot;">​</a></h3><p>Heap File 是一个无序的 Page 集合，这些 Page 在逻辑上没有顺序，都是随机的，Page 里的 Tuples 也是无序的，当你插入一条数据时，系统找到第一个有空位的地方就会把它放进去，不会考虑任何排序。</p><p>由于 Heap File 是无序的，插入新数据时，要找到空闲的位置，不能每次都遍历整个文件来寻找，这样太慢了，因此会使用 Page Directory 来管理。</p><p>在单数据库文件中，定位只需要进行简单的数学计算就好</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>物理地址 = 文件起始地址 + (Page ID * Page Size)</span></span></code></pre></div><p>在多数据库文件中，需要先找到 Page 在哪个文件里，这里就需要通过 Page Directory ，它会找到 Page 的位置，然后通过简单的数学计算就可以了</p><h4 id="page-directory" tabindex="-1">Page Directory <a class="header-anchor" href="#page-directory" aria-label="Permalink to &quot;Page Directory&quot;">​</a></h4><p>Page Directory 不存储用户数据，指挥存储 Metadata ，也就是关于数据的数据。</p><p>Page Directory 的职责</p><ul><li><strong>追踪 Data Page 的位置</strong><blockquote><p>它维护一个映射关系，告诉系统某个逻辑对象（如表X、索引Y）的数据页都存储在哪些物理文件里。</p></blockquote></li><li><strong>追踪 Meta Page 的内容</strong><ul><li><strong>管理空闲空间(Free Space Map - FSM)</strong><blockquote><p>它记录了每个 Page 还剩下多少可用空间。当需要插入数据时，系统直接查询这个“地图”，就能快速找到一个有空位的 Page ，而无需进行代价高昂的全表扫描。</p></blockquote></li><li><strong>记录空闲 Page</strong><blockquote><p>记录哪些 Page 是完全空的，可以被快速分配</p></blockquote></li><li><strong>Page 类型(Page type)</strong><blockquote><p>记录 Page 是存储用户数据，存储(Meta-data) ，还是存储索引(index)</p></blockquote></li></ul></li></ul><p>Page Directory 麻烦的地方在于需要确保 Page Directory 和 Data Page 保持同步，通常在硬盘里，Page Directory 不需要实时同步，这样可以大幅提高性能。</p><h4 id="page-header" tabindex="-1">Page Header <a class="header-anchor" href="#page-header" aria-label="Permalink to &quot;Page Header&quot;">​</a></h4><p>每个 Page 都会有一个 Header，用来存放这个 Page 的 Metadata。</p><h3 id="page-layout" tabindex="-1">Page Layout <a class="header-anchor" href="#page-layout" aria-label="Permalink to &quot;Page Layout&quot;">​</a></h3><p>数据库通常有两种存储方式：</p><ol><li>行式存储</li><li>列式存储</li></ol><p>但是行式存储是更为常见的。</p><p>数据库表通常有三种存储方式：</p><ol><li>Tuple-oriented Storage</li><li>Log-structured Storage</li><li>Index-organized Storage</li></ol><h4 id="tuple-oriented-storage" tabindex="-1">Tuple-oriented Storage <a class="header-anchor" href="#tuple-oriented-storage" aria-label="Permalink to &quot;Tuple-oriented Storage&quot;">​</a></h4><p>Tuple-oriented Storage 的存储方式就是将数据一行行完整的保存下来。<br> 但是这种存储方式有一个问题，就是当存储了多条数据，中间的数据被删掉后，再添加新的数据时，如果想要添加到被刚刚删除的空位中，需要遍历整个数据库，这是一个非常慢的操作。</p><h5 id="slotted-pages" tabindex="-1">Slotted Pages <a class="header-anchor" href="#slotted-pages" aria-label="Permalink to &quot;Slotted Pages&quot;">​</a></h5><p>Slotted Page 是用来解决刚刚提到的问题的技术。<br> Slotted Page 的原理就是，在 Page 的开头，使用一个 Header ， Header 中有一个固定大小的数组，它会取映射 tuples 的起始位置和偏移量。</p><p>但是 Slotted Page 也有缺点，就是当写入的数据都是小数据时，会出现 Header 的数组已经被写满了，但是 Page 还有空间的情况。</p><p>Slotted Page 最大的优点在于，当需要移动数据位置的时候，只需要更新 Header 中的数组，不需要取更新其他的东西。</p><h3 id="tuple-layout" tabindex="-1">Tuple Layout <a class="header-anchor" href="#tuple-layout" aria-label="Permalink to &quot;Tuple Layout&quot;">​</a></h3><p>从本质上来说 Tuple 就是一堆字节，每个 Tuple 拥有一个 Header 。</p><h4 id="tuple-header" tabindex="-1">Tuple Header <a class="header-anchor" href="#tuple-header" aria-label="Permalink to &quot;Tuple Header&quot;">​</a></h4><p>Tuple Header 会包括一些关于 Tuple 的 Metadata，例如：可见性，空值。</p><h4 id="tuple-data" tabindex="-1">Tuple Data <a class="header-anchor" href="#tuple-data" aria-label="Permalink to &quot;Tuple Data&quot;">​</a></h4><p>它会根据表的字段进行顺序存储。</p><h5 id="word-alignment-padding" tabindex="-1">Word-Alignment: Padding <a class="header-anchor" href="#word-alignment-padding" aria-label="Permalink to &quot;Word-Alignment: Padding&quot;">​</a></h5><p>现在的 CPU 大多都是 64-bits ，每次读取数据也会读取 64-bits ，当数据的长度小于 64-bits 时，就有可能读取到相邻字段的数据，为了解决这个问题通常会使用进行填充对齐。</p><p>Tuple 的不同字段长度不同，为了方便系统的读取，通常会使用 64-bits 作为每个字段的长度，如果一个字段类型不满 64-bits，就会使用 0 进行填充用于对齐。</p><p>这样虽然会浪费空间，但是它能确保不读取到错误的数据。</p><h4 id="null-data-types" tabindex="-1">Null Data Types <a class="header-anchor" href="#null-data-types" aria-label="Permalink to &quot;Null Data Types&quot;">​</a></h4><p>空值处理通常有三种方法：</p><ol><li>在 Tuple Header 中定义，不需要管数据是否真的为空， Header 定义为空就是空。</li></ol><blockquote><p>这也是最常用的方法</p></blockquote><ol start="2"><li>使用一个特殊的值以表示空值，然后不允许插叙该值。</li></ol><blockquote><p>这种方法在列存储中比较常见，这是一种较为罕见的方法，缺点是每种类型都有一个值不能使用</p></blockquote><ol start="3"><li>为每个值专门设置一个属性，用于判断是否为空值。</li></ol><blockquote><p>非常弱智，不要使用</p></blockquote><h4 id="large-values" tabindex="-1">Large Values <a class="header-anchor" href="#large-values" aria-label="Permalink to &quot;Large Values&quot;">​</a></h4><p>大多数数据库不允许 Tuple 超过单个 Page 的范围。</p><p>如果想要存储大于一个 Page 的值，通常会存储一个指针，用于指向一个新的 Page 。</p><h4 id="external-value-storage" tabindex="-1">External Value Storage <a class="header-anchor" href="#external-value-storage" aria-label="Permalink to &quot;External Value Storage&quot;">​</a></h4><p>如果使用数据库存入一个大文件，会出现 BLOB(Binary Large Object) 问题，数据会被切分成很多个块，存在多个 Page 里，这会给 Buffer Pool 造成巨大的压力，而且性能十分低，非常弱智。</p><p>当数据库需要保存一个超大的东西时，例如一部 20GB 的电影，更好的做法是将文件存在文件系统中，然后将文件系统的指针存入数据库中。<br> 但是这种解决办法有缺点：</p><ul><li>数据库不能管控</li><li>没有事务的保护</li></ul>',72)])])}const h=a(o,[["render",i]]);export{c as __pageData,h as default};
