import{_ as a,c as l,o,ae as c}from"./chunks/framework.tuuL-SzM.js";const _=JSON.parse('{"title":"Lab: page tables","description":"","frontmatter":{},"headers":[],"relativePath":"course/6.S081/Lab3.md","filePath":"course/6.S081/Lab3.md"}'),r={name:"course/6.S081/Lab3.md"};function s(t,e,d,i,p,n){return o(),l("div",null,e[0]||(e[0]=[c('<h1 id="lab-page-tables" tabindex="-1">Lab: page tables <a class="header-anchor" href="#lab-page-tables" aria-label="Permalink to &quot;Lab: page tables&quot;">​</a></h1><h2 id="speed-up-system-calls-easy" tabindex="-1">Speed up system calls(easy) <a class="header-anchor" href="#speed-up-system-calls-easy" aria-label="Permalink to &quot;Speed up system calls(easy)&quot;">​</a></h2><p><strong>实验思路</strong></p><ol><li>首先是看 <em>kernel/memlayout.h</em> ，能看到里面有一个 <code>USYSCALL</code> 的宏，还有一个 <code>struct usyscall</code> 的结构体，看题能知道，这题就是希望使用这个 <code>usyscall</code> 让用户态的程序获取 pid 的时候不切换内核态</li><li>根据提示，找到 <em>kernel/proc.c</em> 的 <code>proc_pagetable()</code> 函数，在这里可以实现映射，根据上一条思路，和这里的这个函数一起观看会发现，这个函数还实现了了另外两个宏的映射，因此，模仿着它的映射，就可以了。但是会发现 <code>proc</code> 结构体里没有宏对应的变量，因此需要手动添加一个</li><li>提示里还说要注意选择权限的比特位，由于不知道权限的比特位，需要看一下书，看完书就知道比特位在 <em>kernel/riskv.h</em> 中也有宏的定义，直接使用就好了</li><li>根据提示，在 <code>allocproc()</code> 函数中，需要初始化 <code>usyscall</code> ，同时也能看到这个函数里初始化另外一个宏，在它下面模仿着初始化就可以了</li><li>根据提示，和上一条思路一样修改方法，修改 <code>freeproc()</code></li><li>这时候运行会出现 <code>panic: freewalk: leaf</code> 的错误，看到 <strong>free</strong> ，猜到也许是 <code>freeproc()</code> 的问题，仔细看修改过的代码，没发现什么问题，由于改动和页表相关，去看一下 <code>proc_freepagetable()</code> ，发现这里没有 ummap USYSCALL ，添加一条 ummap USYSCALL 就可以了</li></ol><p><strong>踩到的坑</strong></p><ol><li>在 <code>allocproc()</code> 函数中，我把初始化 usyscall 写到了初始化页表后面，导致初始化页表出现了缺页异常，找了了十分久才发现</li></ol><h2 id="print-a-page-table-easy" tabindex="-1">Print a page table(easy) <a class="header-anchor" href="#print-a-page-table-easy" aria-label="Permalink to &quot;Print a page table(easy)&quot;">​</a></h2><p><strong>实验思路</strong></p><ol><li>定义一个 <code>vmprint()</code> 函数在 <em>kernel/vm.c</em> 中，由于是打印页表，因此参数就是一个页表</li><li>根据示例，直接使用 <code>%p</code> 打印第一行地址，也就是页表的第一条地址</li><li>页表的转换需要使用位运算，这个在 <em>kernel/riscv.h</em> 中有宏定义好了，页表的其他信息里面也有宏定义好了，直接调用即可</li><li>参考 <code>freewalk()</code> 函数，是释放页表，释放页表需要遍历，因此可以直接将整个函数复制过来修改，但是由于需要递归操作，所以新建一个<code>_print_pgtbl()</code> 函数，将 <code>freewalk()</code> 复制进去，新函数的参数是页表和层级，层级用于判断递归的层数</li><li>页表中有一个位是 <code>PTE_V</code> ，在 <em>kernel/riscv.h</em> 可以得知，这个位是判断页表是否有效的。对于无效的页表，直接跳过就好，对于有效的页表，直接按格式打印层级和地址</li><li>打印完之后需要判断该页表是不是叶子的页表，判断的方法通过课程或者 xv6 book 可以知道，当 <code>PTE_R PTE_W PTE_X</code> 都等于 0 的时候，页表有子页表，否则是叶子页表，如果不是叶子页表，直接递归同时层级加一就行了</li></ol>',9)]))}const b=a(r,[["render",s]]);export{_ as __pageData,b as default};
