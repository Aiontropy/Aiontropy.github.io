import{_ as e,c as t,o as s,ae as o}from"./chunks/framework.tuuL-SzM.js";const u=JSON.parse('{"title":"6.S081 LEC4","description":"","frontmatter":{},"headers":[],"relativePath":"course/6.S081/course_note_p4.md","filePath":"course/6.S081/course_note_p4.md"}'),r={name:"course/6.S081/course_note_p4.md"};function n(l,a,i,p,c,d){return s(),t("div",null,a[0]||(a[0]=[o('<h1 id="_6-s081-lec4" tabindex="-1">6.S081 LEC4 <a class="header-anchor" href="#_6-s081-lec4" aria-label="Permalink to &quot;6.S081 LEC4&quot;">​</a></h1><p>Page Tables.</p><h2 id="页表-page-tables" tabindex="-1">页表 (Page tables) <a class="header-anchor" href="#页表-page-tables" aria-label="Permalink to &quot;页表 (Page tables)&quot;">​</a></h2><h3 id="隔离-isolution" tabindex="-1">隔离 (Isolution) <a class="header-anchor" href="#隔离-isolution" aria-label="Permalink to &quot;隔离 (Isolution)&quot;">​</a></h3><p>使用虚拟内存可以获得强隔离性。</p><h3 id="地址空间-address-spaces" tabindex="-1">地址空间 (Address spaces) <a class="header-anchor" href="#地址空间-address-spaces" aria-label="Permalink to &quot;地址空间 (Address spaces)&quot;">​</a></h3><p>为什么要有地址空间？假如现在有一个场景，内存地址 1000-2000 是程序 A 的地址，内存地址 3000-4000 是程序 B 的地址，程序 B 执行了一个向 100 地址的写操作，然后这个操作就会被写道程序 A 的地址中，这样就打破了内存隔离。</p><p>它的基本思想很简单，就是我们给每个程序，包括内核分配自己的地址空间。不适用地址空间，就像把内存比作一桶水，每个程序都可以任意污染水，而内存地址就像把水用杯子装起来，每个程序都只能污染自己的那一杯水。这样就实现了强隔离性。</p><h3 id="页表-page-tables-1" tabindex="-1">页表 (Page tables) <a class="header-anchor" href="#页表-page-tables-1" aria-label="Permalink to &quot;页表 (Page tables)&quot;">​</a></h3><p>实现地址空间最常见方法就是使用<strong>页表</strong>，这通常是由处理器或者 <strong>内存管理单元(Memory Manager Unit MMU)</strong> 的硬件实现的。当 CPU 执行任何和地址有关的指令时，这个地址都是虚拟地址，虚拟地址通过 MMU 转换成物理地址，然后使用这个物理地址在内存中索引，进行操作。<br> 在 MMU 中，通常存储着一张不完整的表，它叫做 <strong>转换检测缓冲区(Translation Lookaside Buffer)</strong> ，表的一个字段是虚拟地址，另一个字段是物理地址，这张完整的表通常保存在内存中。 CPU 会由一个寄存器存储这张表的位置， RISC-V 中，这个寄存器叫做 <strong>satp</strong> ，保存着表在内存中的地址，当要寻找地址时， CPU 会告诉 MMU 在哪里可以找到这张完整的表，当 CPU 切换进程运行的时候，也会切换 stap 寄存器，指向运行的程序的映射，而被写进 satp 的值是由内核保存的。</p><h2 id="栈" tabindex="-1">栈 <a class="header-anchor" href="#栈" aria-label="Permalink to &quot;栈&quot;">​</a></h2><p>内核栈位于内存中较高的位置，原因是有一个没有映射的 <strong>守护页(Guard page)</strong> 在它的下面，内核栈下面的一些内存会是无效内存，如果栈溢出，出现页错误，也只会溢出到无效内存中，这样也比其他的内核内存被修改比较合理。</p><blockquote><p>守护页只存在于虚拟地址中，它没有对应的物理地址，因此也不会消耗物理内存。</p></blockquote><p>每个用户程序都有自己的用户栈。</p>',14)]))}const _=e(r,[["render",n]]);export{u as __pageData,_ as default};
